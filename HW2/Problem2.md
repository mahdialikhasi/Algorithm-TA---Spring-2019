+ محدودیت زمان: ۱ ثانیه
+ محدودیت حافظه: ۲۵۶ مگابایت

----------
یکی از توابعی که در کلاس مطرح و معرفی شده است تابع mergeSort میباشد که برای مرتب سازی آرایه ها به کار میرود.
در این تابع برای یک آرایه که اندیس های آن به شکل $]l,r)$ است به ترتیب زیر عمل میکنیم.

1.  If the segment [_l_, _r_) is already sorted in non-descending order (that is, for any _i_ such that _l_ ≤ _i_ < _r_ - 1 _a_[_i_] ≤ _a_[_i_ + 1]), then end the function call;
2.  Let mid = floor((l + r) / 2);
3.  Call _mergesort_(_a_, _l_, _mid_);
4.  Call _mergesort_(_a_, _mid_, _r_);
5.  Merge segments [_l_, _mid_) and [_mid_, _r_), making the segment [_l_, _r_) sorted in non-descending order. The merge algorithm doesn't call any other functions.

آرش تابع mergeSort رو به شکل بالا پیاده سازی کرده است و علاوه بر آن تابعی نوشته است که تعداد فراخوانی های تابع mergesort رو نیز میشماره. ولی حالا نیاز داره که کد خودش رو تست کنه و برای همین از شما کمک میخواد.

به آرش کمک کنید که یک جایگشت از طول n پیدا کنه (یعنی یه آرایه به طول n پیدا کنه که مقادیر اون آرایه به ترتیب از 1 تا n باشن) که تعداد فراخوانی های mergesort روی این آرایه دقیقا k بار باشه.

# ورودی
در تنها خط ورودی ابتدا n و سپس k آمده است که این دو عدد با یک فاصله از همدیگر جدا شده اند.

$$1 \le n \le 100000$$
$$1 \le k \le 200000$$
# خروجی
در تنها خط خروجی شما باید یک جایگشت از آرایه ی مطلوب ایجاد کنید :)
اگر چنین جایگشتی وجود ندارد - 1 چاپ کنید
در صورتی که چند جواب مناسب وجود داشت هرکدام از آنها را میتوانید چاپ کنید.

# مثال
## ورودی نمونه ۱
```
3 3
```


## خروجی نمونه ۱
```
2 1 3
```


## ورودی نمونه ۲
```
4 1
```


## خروجی نمونه ۲
```
1 2 3 4
```
